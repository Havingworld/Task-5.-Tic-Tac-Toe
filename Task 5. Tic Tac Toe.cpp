/*Задание 5. Анализ результатов игры в крестики-нолики

Что нужно сделать
Петя и Вася играли в крестики-нолики и не стёрли результаты своей игры. Теперь перед вами табличка 3 × 3,
которая осталась после их поединка. Вы хотите понять, выиграл ли кто-то из них или они не доиграли.
На вход программе даётся три строки, кодирующие верхнюю, среднюю и нижнюю строчки игрового поля.
Крестик обозначается символом X (английская заглавная буква X), нолик — символом O (заглавная латинская буква O),
пустая клетка — точкой.
Если ввод некорректен, то есть такая таблица не могла получиться в ходе настоящей игры, то надо написать в ответ слово Incorrect.
Если таблица корректна и выиграли крестики, то нужно вывести в ответ слова Petya won,
если нолики — то Vanya won, а иначе (то есть они не доиграли или сыграли вничью) надо написать Nobody.

Примеры

X..
OXO
OOO

Ответ: Incorrect (потому что ноликов в конце игры не может быть больше, чем крестиков).

X..
.X.
OO.

Ответ: Nobody (потому что они не доиграли).

XXO
OOX
XOX

Ответ: Nobody (потому что это ничья).

XO.
XO.
X.O

Ответ: Incorrect (крестики уже победили, и ноликов не может быть столько же).

OX.
XOX
X.O

Ответ: Incorrect (потому что нолики выиграли за три хода, и на поле за это время не могло успеть появиться четыре крестика).

..X
OX.
X.O

Ответ: Petya won.

0..
...
...

Ответ: Incorrect (потому что допускаются только символы X, O и точка, а цифра 0 не является допустимым символом).

Советы и рекомендации
Активно используйте оператор индексации строки str[i], но помните что индексы начинаются с нуля, а не с единицы.
Для того, чтобы обращаться к элементам игрового поля, стоит написать отдельную функцию получения элемента поля по его координатам (x, y). В таком случае, часть алгоритмов поиска победителя можно обобщить.
Функции проверки поля на корректность можно отделить от функций и алгоритмов проверки победителя.
При достаточной модульности функций, некоторые операции можно реализовать через уже существующие процедуры. К примеру, если уже есть проверка победителя в строке и имеется функция получения колонки по индексу, то функцию поиска победителя в колонке можно реализовать через обе них.
Проход по диагонали поля можно осуществить в цикле, используя счётчик цикла в качестве обоих координат элемента. Для второй диагонали нужно обратить одну из координат (2 - x или 2 - y).
Общие условия некорректности поля таковы: 
Выявлено несколько победителей одновременно
Нолики победили, а крестиков больше чем ноликов
Крестики победили, а ноликов столько же или больше
Нолики и крестики победили несколько раз
На поле есть невалидные символы


Что оценивается
Корректность работы программы по анализу игры на различных вводных данных.



Как отправить задание на проверку
Прислать ссылку на repl.it или файл .срр с решением. Также вы можете создать открытый репозиторий в GitHub с содержимым проекта.
*/

#include <iostream>
#include <string>
using namespace std;

//X == 88
//O == 79
//. == 46

string LineToAnswer(string szLine0, string szLine1, string szLine2) {
  //check input
    for (int n = 0; n < 3; n++) {
        if (
            (szLine0[n] == '.' || szLine0[n] == 'O' || szLine0[n] == 'X')
            && (szLine1[n] == '.' || szLine1[n] == 'O' || szLine1[n] == 'X')
            && (szLine2[n] == '.' || szLine2[n] == 'O' || szLine2[n] == 'X')
            )
        {
            continue;
        }
            else
        {
            return "Incorrect input";
            break;
        } 
    }
    //count X and O
    int nCountX = 0, nCountO = 0;
    for (int n = 0; n < 3; n++) {
        if (szLine0[n] == 'X') nCountX++;
        if (szLine0[n] == 'O') nCountO++;
        if (szLine1[n] == 'X') nCountX++;
        if (szLine1[n] == 'O') nCountO++;
        if (szLine2[n] == 'X') nCountX++;
        if (szLine2[n] == 'O') nCountO++;
    }

    //part to adress
    char ch00 = szLine0[0], ch01 = szLine0[1], ch02 = szLine0[2];
    char ch10 = szLine1[0], ch11 = szLine1[1], ch12 = szLine1[2];
    char ch20 = szLine2[0], ch21 = szLine2[1], ch22 = szLine2[2];


   // if (X>O)
    if   ( nCountX > nCountO &&
          (ch02 + ch12 + ch22 == 88*3
        ||ch01 + ch11 + ch21 == 88*3
        ||ch00 + ch10 + ch20 == 88*3
        ||ch00 + ch11 + ch22 == 88*3
        ||ch20 + ch11 + ch02 == 88*3
        ||ch20 + ch21 + ch22 == 88*3
        ||ch10 + ch11 + ch12 == 88*3
        ||ch00 + ch01 + ch22 == 88*3
            )
        )
    {
        return "X won!";
    } 
  // if (X<O)
    else if (nCountX == nCountO &&
        (ch02 + ch12 + ch22 == 79 * 3
        || ch01 + ch11 + ch21 == 79 * 3
        || ch00 + ch10 + ch20 == 79 * 3
        || ch00 + ch11 + ch22 == 79 * 3
        || ch20 + ch11 + ch02 == 79 * 3
        || ch20 + ch21 + ch22 == 79 * 3
        || ch10 + ch11 + ch12 == 79 * 3
        || ch00 + ch01 + ch22 == 79 * 3
        )
        )
    {
        return "O won!";
    }
    else if (
           (nCountX == nCountO &&
           (ch02 + ch12 + ch22 == 88 * 3
         || ch01 + ch11 + ch21 == 88 * 3
         || ch00 + ch10 + ch20 == 88 * 3
         || ch00 + ch11 + ch22 == 88 * 3
         || ch20 + ch11 + ch02 == 88 * 3
         || ch20 + ch21 + ch22 == 88 * 3
         || ch10 + ch11 + ch12 == 88 * 3
         || ch00 + ch01 + ch22 == 88 * 3))
         || nCountX < nCountO)
            {
                return "Incorrect input";
             }
    else {
        return "nobody";
    }
}

int main()
{
    cout << "insert game:" << endl;
    string szLine1, szLine2, szLine3;
    cin >> szLine1 >> szLine2 >> szLine3;
    cout << LineToAnswer(szLine1, szLine2, szLine3);
}


